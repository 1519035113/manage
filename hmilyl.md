## 闭包 
    一个函数的返回值是另一个函数，这个函数调用了父函数的变量，
    并且在外部被调用就生成了一个闭包

    函数嵌套函数，内部函数可以访问外部函数的变量，变量不会被垃圾回收机制回收

    优点：变量长期驻扎内存中、避免全局污染、私有成员存在
    缺点：变量常驻内存、增大内存使用量、使用不当会导致内存泄露
## 作用域
    ^变量作用域，就是一个变量可以使用的范围
    ^作用域分为 全局作用域、函数作用域、块级作用域（ES6新增）
        全局作用域：可以在全局中使用
        函数作用域：通过函数创建一个独立的作用域
        ES6新增中新增了块级作用域 （只适用于let、const）
    ^自由变量的概念： 当前作用域没有定义的变量
    ^自由变量的向上级作用域一层一层查找，直到找到为止，
    最高找到全局作用域，就形成了作用域链

## 原型与原型链
    ^每个函数都有一个prototype属性，被称为显示原型
    ^每个实例对象都会有_ _proto_ _属性,其被称为隐式原型
    ^每一个实例对象的隐式原型指向自身构造函数的显式原型 
    ^每个prototype原型都有一个constructor属性，指向它关联的构造函数
    ^原型链
    获取对象属性时，如果对象本身没有这个属性，那就会去他的原型__proto__上去找，
    如果还查不到，就去找原型的原型，一直找到最顶层(Object.prototype)为止。
    Object.prototype对象也有__proto__属性值为null。
## 继承
    ^原型链继承、构造函数继承、组合式继承（原型链+构造函数）
    ^原型链继承就是将父类的实例作为子类的原型
    优点：简单易于实现，父类新增的属性子类都能访问
    缺点：无法实现多继承、不能传参
    ^借用构造函数继承就是改变子类中的this指向（复制父类的实例属性给子类）
    优点：可以传参、可以实现多继承
    缺点：不能使用父类原型上的方法和属性
    ^组合式继承就是调用父类构造函数，继承父类的属性，通过将父类实例作为子类原型，实现函数复用
    优点：函数可以复用、不存在引用属性问题、可以继承属性和方法，并且可以继承原型的属性和方法
    缺点：由于调用了两次父类，所以产生了两份实例
    ^es6继承代码量少，易懂
## 深拷贝


## promise
    ^Promise简单来说就是一个容器，里边保存这一个某个未来才会结束的事件的结果
    ^从语法生说promise是一个对象，通过它可以获取异步操作的的最终状态
    ^Promise是一个构造函数，对外提供统一的api，自身有all、resolve、reject方法，
    它的原型上有then、catch方法
        then用来捕获异步操作成功resolve返回的信息
        catch用来捕获异步操作失败reject返回的信息
    ^可以链式调用，解决地狱回调问题
    ^promise有三种状态 pending（初始状态）fulfilled（成功状态）rejected（失败状态）
        它的状态不受外界影响，只有异步操作的结果可以决定当前是那一状态
    ^promise的状态一旦改变就不会在变只能由 pending变成fulfilled或者由pending变成rejected

## async/await
    ^async表示函数中有异步操作 await表示需要表达式返回结果
    ^
    ^
    ^
    ^

## 双向数据绑定
    ^利用数据劫持结合订阅者和发布者，利用object.defineproperty()来劫持各个属性的
    getter和setter，在数据发生改变的时候通知订阅者，触发监听回调更新视图
    ^具体步骤

    ^
    ^

## vue Virtual Dom和Diff

    ^
    ^
    ^
    ^

## 组件通信


## vuex 
    ^veux是一个专为vue.js开发的状态管理器，采用集中式存储的所有组件状态
    ^五个属性： state、getters、mutations、actions、module
    ^state 存放数据  
     getters 类似于共享属性，可以通过this.$store.getters来获取存放在- state里面的数据
     mutations： 唯一能改变state的状态就是通过提交mutations来改变，this.$store.commit()
     actions: 异步的mutations，可以通过dispatch来分发从而改变state
    ^数据持久化：vuex里面存放的数据，页面一经刷新会丢失
    ^解决办法： 存放在localStorage或者sessionStorage里面，进入页面时判断是否丢失，
     丢失再去localStorage或者sessionStorage里面取；

## 路由守卫

## 生命周期
    ^答： 总共分为8个阶段。创建前/后，载入前/后，更新前/后，销毁前/后
    ^创建前/后： 在beforeCreated阶段，vue实例的挂载元素$el和数据对象 data 都为undefined，
    还未初始化。在 created阶段，vue实例的数据对象data有了，$el还没有

    ^载入前/后： 在beforeMount阶段，vue实例的$el和data都初始化了，但还是挂载之前为虚拟的
    dom节点，data.message还未替换。在mounted阶段，vue实例挂载完成，data.message成功渲染。

    ^更新前/后： 当data变化时，会触发beforeUpdate和updated方法。

    ^销毁前/后： 在destroy阶段，对data的改变不会再触发周期函数，说明此时vue实例已经解除了事
    件监听以及和dom的绑定，但是dom结构依然存在。destroyed阶段，组件销毁
    

## keep-alive

    ^<keep-alive>它是vue的内置组件可以在组件切换的过程中将状态保留在内存中，取消组件的销毁函数，防止重复渲染DOM
    ^当用它包裹 <router-view> 时，会缓存不活动的组件实例，而不是销毁它们
    ^和 <transition> 相似，它自身不会渲染一个 DOM 元素
    ^使用 <keep-alive> 组件后即可使用 activated() 和 deactivated() 这两个生命周期函数
    ^应用场景
例如我们将某个列表类组件内容滑动到第100条位置，那么我们在切换到一个组件后再次切换回到该
组件，该组件的位置状态依旧会保持在第100条列表处
被keep-alive包裹的动态组件或router-view会缓存不活动的实例，再次被调用这些被缓存的实例会被
再次复用，对于我们的某些不是需要实时更新的页面来说大大减少了性能上的消耗，不需要再次发送
HTTP请求，但是同样也存在一个问题就是被keep-alive包裹的组件我们请求获取的数据不会再重新渲
染页面，这也就出现了例如我们使用动态路由做匹配的话页面只会保持第一次请求数据的渲染结果，
所以需要我们在特定的情况下强制刷新某些组件
    ^include属性表示只有name属性为bookLists，bookLists的组件会被缓存其它组件不会被缓存
    ^exclude属性表示除了name属性为indexLists的组件不会被缓存，其它组件都会被缓存

## 自定义组件/自定义指令
    ^自定义组件：
        我用vue开发的所有项目，都是采用组件化的思想开发的。一般我在搭建项目的时候，会创建一个views目录和一个commen目录和一个feature目录，views目录中放页面级的组件，commen中放公共组件（如：head（公共头组件），foot（公共底部组件）等），feature目录内放功能组件（如：swiper(轮播功能组件)，tabbar(切换功能组件)、list(上拉加载更多功能组件)）

        首先，组件可以提升整个项目的开发效率。能够把页面抽象成多个相对独立的模块，解决了我们传统项目开发：效率低、难维护、复用性低等问题。

        使用Vue.extend方法创建一个组件，然后使用Vue.component方法注册组件。但是我们一般用脚手架开发项目，每个 .vue单文件就是一个组件。在另一组件import 导入，并在components中注册，子组件需要数据，可以在props中接受定义。而子组件修改好数据后，想把数据传递给父组件。可以采用emit方法。
    ^自定义指令：
        自定义指令分为：全局自定义指令，局部自定义指令
         使用Vue.directive('focus',{bind(el,binding){},inserted(){}})进行全局自定义指令
         参数1 ：指令的名称
         参数2： 是一个对象，这个对象身上，有钩子函数
        钩子函数：
         inserted：被绑定元素插入父节点时调用 (仅保证父节点存在，但不一定已被插入文档中)。

         bind：只调用一次，指令第一次绑定到元素时调用。在这里可以进行一次性的初始化设置。

         update：所在组件的 VNode 更新时调用，但是可能发生在其子 VNode 更新之前。指令的值可能发生了改变，也可能没有。但是你可以通过比较更新前后的值来忽略不必要的模板更新 (详细的钩子函数参数见下)。

         componentUpdated：指令所在组件的 VNode 及其子 VNode 全部更新后调用。

         unbind：只调用一次，指令与元素解绑时调用。

        指令钩子函数会被传入以下参数：

         el：指令所绑定的元素，可以用来直接操作 DOM 在每个函数中，第一个参数el ，表示被绑定了指令的那个元素，这个 el 参数，是一个原生的JS对象,。
         binding：一个对象，包含以下属性：
         name：指令名，不包括 v- 前缀。
         value：指令的绑定值，例如：v-my-directive=“1 + 1” 中，绑定值为 2。
         oldValue：指令绑定的前一个值，仅在 update 和 componentUpdated 钩子中可用。无论值是否改变都可用。
         expression：字符串形式的指令表达式。例如 v-my-directive=“1 + 1” 中，表达式为 “1 + 1”。
         arg：传给指令的参数，可选。例如 v-my-directive:foo 中，参数为 “foo”。
         modifiers：一个包含修饰符的对象。例如：v-my-directive.foo.bar 中，修饰符对象为 { foo: true, bar: true }。
         vnode： Vue编译生成的虚拟节点。移步 VNode API 来了解更多详情。
         oldVnode：上一个虚拟节点，仅在 update 和 componentUpdated 钩子中可用

## 跨域（jsonp、proxy）
    ^协议、域名、端口三者相同为同源，有一个不同就是跨域
    ^jsonp 本质上是一个Hack，它利用<script>标签不受同源策略限制的特性进行跨域操作
     jsonp优点：实现简单 兼容性非常好
     jsonp的缺点：只支持get请求 有安全性问题，容易遭受xss攻击 有安全性问题，容易遭受xss攻击
    ^cors 
     是目前主流的跨域解决方案，跨域资源共享(CORS) 是一种机制，它使用额外的 HTTP 头来告诉浏览器 让运行在一个 origin (domain) 上的Web应用被准许访问来自不同源服务器上的指定的资源。当一个资源从与该资源本身所在的服务器不同的域、协议或端口请求一个资源时，资源会发起一个跨域 HTTP 请求
    ^Nginx 在生产环境中建议用成熟的开源中间件解决问题
        nginx是一款极其强大的web服务器，其优点就是轻量级、启动快、高并发
        现在的新项目中nginx几乎是首选，我们用node或者java开发的服务通常都需要经过nginx的反向代理
        反向代理的原理很简单，即所有客户端的请求都必须先经过nginx的处理，nginx作为代理服务器再讲请求转发给node或者java服务，这样就规避了同源策略
    ^

## 状态码
    ^http状态码分类：
    100-199 提示信息 – 表示请求正在处理
    200-299 成功 – 表示请求正常处理完毕
    300-399 重定向 – 要完成请求必须进行更进一步的处理
    400-499 客户端错误 – 请求有语法错误或请求无法实现
    500-599 服务器端错误 – 服务器处理请求出错
    ^常见的状态吗有哪些：
    ①　200：请求成功，浏览器会把响应体内容（通常是html）显示在浏览器中；
    ②　404：(客户端问题)请求的资源没有找到 400: 语义有误，当前请求无法被服务器理解。401: 当前请求需要用户验证 403: 服务器已经理解请求，但是拒绝执行它。
    ③　500：(服务端问题)请求资源找到了，但服务器内部发生了不可预期的错误；
    ④　301/302/303：(网站搬家了，跳转)重定向
    ⑤　304: Not Modified,代表上次的文档已经被缓存了,还可以继续使用。如果你不想使用本地缓存可以用Ctrl+F5 强制刷新页面

## 输入url到页面发生了什么
    1、浏览器的地址栏输入URL并按下回车。

    2、浏览器查找当前URL是否存在缓存，并比较缓存是否过期。

    3、DNS解析URL对应的IP。

    4、根据IP建立TCP连接（三次握手）。

    5、HTTP发起请求。

    6、服务器处理请求，浏览器接收HTTP响应。

    7、渲染页面，构建DOM树。

    8、关闭TCP连接（四次挥手）。
## 